개요

javascript의 브라우저 런타임은 싱글 쓰레드기반이지만 이벤트 루프를 통해 비동기 작업을 처리할 수 있습니다. 이번 글에서는 이벤트 루프가 어떤것이고,

이벤트 루프가 대략적으로 어떻게 동작하는지 알아보겠습니다.

## 이벤트 루프

> 태스크가 들어오면 이를 처리하고 처리할 태스크가 없으면 잠듭니다. 이 행동을 계속 반복합니다.

1. 처리해야할 태스크가 있는 상태 :

→ 먼저 들어온 태스크부터 순차적으로 처리합니다.

1. 처리해야할 태스크가 없는상태 :

→ 잠들어 있다가 새로운 태스크가 들어오면 1로 돌아갑니다.

여기서 태스크는 다음과 같습니다.

- 외부 스크립트 `<script src="...">` 가 로드될 때 , 이 스크립트를 실행하는 것.
- 사용자가 마우스를 움직일 때 `mousemove` 이벤트와 이벤트 핸들러를 실행하는 것.
- setTimeout 에서 설정한 시간이 다 된 경우, 콜백 함수를 실행하는 것.
- 기타 등등

자바스크립트 엔진은 집합을 이루고 있는 태스크를 차례로 처리하고, 새로운 태스크가 큐에 추가될 때 까지 기다립니다. 태스크를 기다리는 동안에는 CPU 자원 소비는 0에 가까워지고, 엔진은 잠들게 됩니다.

## 매우 긴 태스크를 처리한다면..?

자바스크립트 엔진이 태스크를 처리하는 동안 렌더링은 일어나지 않습니다. 만약 태스크를 처리하는데 걸리는 시간이 길지 않으면 문제가 되지 않겠지만 시간 길다면? 유저는 기약없이 멈춘 브라우저 화면만 바라보고 있어야할 것입니다.

만약 태스크 처리에 긴 시간이 걸린다면, 브라우저는 태스크를 처리하는 동안에 발생한 태스크를 처리하지 못합니다. 아마도 아래 얼럿창이 출력 될 것이며, 사용자에게 페이지 전체와 함께 해당 태스크를 취소할지 말지 선택하도록 유도합니다.

![프론트엔드 개발자라면 섬뜩한 메시지임에 틀림 없습니다.](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/12f3c669-00e9-4a72-8228-5207ecb2d073/Untitled.png)

프론트엔드 개발자라면 섬뜩한 메시지임에 틀림 없습니다.

## 매크로 태스크 큐(or 콜백 큐, 이벤트 큐)

태스크들(script, mousemove, setTimeout, etc..)이 추가되는 큐 입니다. (참고로 promise는 마이크로 태스크 큐에서 처리되는데 좀 더 아래에서 다루겠습니다. )

엔진이 script를 처리하는 중 사용자가 마우스를 움직여 mousemove이벤트를 활성화하고, 바로 이어서 setTimeout에서 설정한 시간이 지났다고 가정해봅시다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/337130f0-2ebf-4697-9279-2f66ef732d62/Untitled.png)

1. 엔진은 `script`를 먼저 처리합니다.
2. `mousemove`이벤트와 핸들러를 처리합니다.
3. `setTimeout`핸들러를 순차적으로 처리합니다.

여기서 잠깐, setTimeout이 처리되는 과정에 대해서 조금 더 설명해보겠습니다.

```tsx
setTimeout(() => console.log("Third Stack"), 1000);
```

1. setTimeout은 스택에 들어갑니다.
2. WebAPI에서 1000초만큼 타이머를 실행시킵니다. (스택, 이벤트루프에서 처리하지 않습니다)
3. 타이머가 완료되면 setTimeout에 등록된 콜백이 이벤트 루프에 들어갑니다.
4. 이벤트 루프에서 3번에 등록된 콜백을 스택에 넣어 처리합니다 (log 출력)

## 마이크로 태스트 큐
