# 1장 타입스크립트 알아보기 - 진행중

- 사진이 깨지는 부분은 1장 정리후 처리 예정

# 타입스크립트와 자바스크립트의 관계

- 타입스크립트는 자바스크립트의 슈퍼셋 언어
- 모든 자바스크립트 코드는 타입스크립트에 속한다고 볼 수 있음.
- 그러나, 일부 자바스크립트만이 타입 체커를 통과함.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/3c0320e0-6312-4511-aacb-03ff6b4f4656/Untitled.png)

타입스크립트는 자바스크립트의 동작을 모델링함.

```tsx
const x = 2 + "3"; //정상
const y = "2" + 3; //정상
```

위 코드는 C, C++, Java에서는 런타임 오류 발생. 그러나 타입 스크립트의 타입 체커는 정상으로 인식.

```tsx
const a = null + 7;
const b = [] + 12;

alert("Hello", "Typescript");
```

런타임에는 문제가 없으나 타입 스크립트의 타입 체커는 에러 표시

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/34b331a3-1b9d-4d59-b545-425ae12025a1/Untitled.png)

- 타입스크립트의 타입 체크는 런타임 오류까지 잡아낼 수 없음.

```tsx
const names = ["Alice", "Bob"];
console.log(names[2].toUpperCase()); //런타임에서 배열의 크기를 벗어난 인덱스 참조.
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/df8d1f18-4223-4b7b-b4a1-a070124a3a2a/Untitled.png)

# 타입스크립트 설정 이해하기

- 타입스크립트는 설정(tsconfig)을 통해 타입 체크 규칙을 설정할 수 있음
- 대표적인 설정에는

  - `noImplicitAny`
    - 암묵적인 any 타입을 허용하지 않음. 기본설정 true 권장.
    - https://www.typescriptlang.org/tsconfig#noImplicitAny
  - `strictNullChecks`
    - null과 undefined가 모든 타입에 할당될 수 있는지 여부를 체크. 기본설정 true 권장

- `noImplicitAny` 과 `strictNullChecks` 는 자바스크립트 에서 타입스크립트로 코드 마이그레이션 시 어려움을 겪게 만드는 원인 중 하나.
- 그러나 신규 타입스크립트 프로젝트를 시작한다면 기본값으로 활성화 시킬것을 권장.

# 코드 생성과 타입은 관계없음을 이해하기.

타입 스크립트 컴파일러는 아래의 두가지 역할을 수행.

1. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구 버전 자바스크립트로 트랜스파일(transpile)
2. 코드의 타입 오류를 체크.

- 이 두가지 역할은 완벽히 독립적으로 수행.
- 타입 체크 에러가 코드 변환에 영향을 미치지 않음.
- 마찬가지로 자바스크립트의 실행 시점에도 타입은 영향을 주지 않음.

따라서 타입 오류가 있는 코드도 컴파일이 가능하며 실행도 가능.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/d3df8bed-d96a-4350-9ed1-eec7193310a0/Untitled.png)

- 단, 트랜스파일 과정에서 타입 체크 에러 발생시 컴파일을 하지 않으려면 `noEmitOnError` 를 설정하거나 빌드 도구에서 동일하게 설정.
- 현업에서는 보통 `noEmitOnError` 를 활성화시켜 사용함.

런타임에는 타입 체크가 불가능.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/dd53d951-c9af-4499-8392-7cc5737bac8e/Untitled.png)

- instanceof 체크는 런타임에 수행. 그러나 Rectangle은 타입이므로 런타임 시점에 아무것도 할 수 없음.
- 자바스크립트로 컴파일 되는 과정에서 삭제됨. 따라서 런타임에 `Rectangle is not defined` 에러 발생

위에 언급된 shape 타입을 명확히 하기 위해서 런타임에 타입정보를 유지하는 방법이 필요.

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20c730680c2b774d17a1ccde853c37e85b/Untitled%205.png)

- Square 타입에만 존재하는 height 속성이 존재하는지 검사. 에러를 해결함.

혹은 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 태그 기법 활용

```tsx
interface Square {
  kind: "square";
  width: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape.kind === "rectangle") {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}

const shape: Square = {
  kind: "square",
  width: 10,
};

console.log(calculateArea(shape));
```

타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용하는 기법.

```tsx
class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.width;
  } else {
    return shape.width * shape.width;
  }
}
```

- 인터페이스는 타입으로만 사용가능하지만, Rectangle을 클래스로 선언하면 타입과 값으로 모두 사용가능.

타입 연산은 런타임에 영향을 주지 않음.

- 위 코드는 string 혹은 number 타입인 값을 항상 number로 정제하는 경우를 가정.

```tsx
function asNumber(val: number | string): number {
  return val as Number;
}
```

- js로 변환된 코드

```jsx
function asNumber(val) {
  return val;
}
```

- 실제 변환된 코드에 아무 정제과정이 없음. (타입은 변환시 휘발되므로)
- 값을 정제하고 싶다면 런타임의 타입을 체크하고 자바스크립트 연산을 통해 변환 수행

```tsx
function asNumber(val: number | string): number {
  return typeof val === "string" ? Number(val) : val;
}
```

런타임 타입은 선언된 타입과 다를 수 있음.

```tsx
function setLightSwitch(value: boolean) {
  switch (value) {
    case true:
      turnLightOn();
      break;
    case false:
      turnLightOff();
      berak;
    default:
      console.log("실행되지 않을까봐 걱정됩니다");
  }
}
```

- value가 boolean값이라 `default` 에 정의된 콘솔이 실행되지 않을 것 같지만 실제 런타임에는 타입을 체크하지 않으므로 다른 값(문자열)이 들어온다면 default가 실행 될 수 있음.
- 타입스크립트는 런타임 타입과 선언된 타입이 맞지 않을 수 있다는 것을 명심.

**타입스크립트 타입으로는 함수를 오버로드 할 수 없음.**

- 타입스크립트에서는 타입과 런타임의 동작이 무관하므로 함수 오버로딩은 불가능함.

![Untitled](1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%8B%E1%85%A1%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20c730680c2b774d17a1ccde853c37e85b/Untitled%206.png)

함수 오버로딩 기능은 지원하기는 하지만, 온전히 타입 수준에서만 동작함.

```tsx
function add(a: number, b: number): number;
function add(a: string, b: string): string;

function add(a, b) {
  return a + b;
}

const three = add(1, 2); //타입이 number
const twelve = add("1", "2"); //타입이 string
```

- add 함수 선언문은 타입스크립트가 자바스크립트로 변환되면서 제거됨.

타입스크립트 타입은 런타임 성능에 영향을 주지 않음. (타입은 컴파일시 제거되므로)

- 런타임 오버헤드가 없는 대신 빌드 타임 오버헤드가 존재.
- 일반적인 타입스크립트 컴파일 성능은 매우 좋은편.
- 호환성(eg: es5 타겟 컴파일)과 런타임 성능은 타입과 무관.

# 구조적 타이밍에 익숙해지기

- 타입스크립트는 본질적으로 [덕 타이핑 기반](https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91)
- 구조적 타이핑을 제대로 이해한다면 오류인 경우와 아닌 경우의 차이를 잘 알 수 있음.

물리 라이브러리와 2D 벡터 타입을 다루는 경우를 가정.

```tsx
interface Vector2D {
  x: number;
  y: number;
}
```

벡터의 길이계산 함수 정의

```tsx
function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
```

이름 속성이 추가된 벡터를 정의

```tsx
interface NamedVerctor {
  name: string;
  x: number;
  y: number;
}
```

NamedVector는 number 타입의 x, y 속성이 있으므로 calculateLength 함수를 호출 할 수 있음.

```tsx
const v: NamedVerctor = { x: 3, y: 4, name: "Zee" };
calculateLength(v); // 정상, 결과는 5
```

- Vector2D와 NamedVector의 관계를 전혀 선언하지 않았음에도 타입스크립트는 구조가 호환되기 때문에 NamedVector는 calculateLength 함수를 호출 가능

다만 구조적 타이핑으로 문제가 발생하는 경우도 있음.

```tsx
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
```

벡터의 길이를 1로 만드는 정규화 함수를 작성.

```tsx
function normalize(v: Vector3D) {
  const length = calculateLength(v);
  return {
    x: v.x / length,
    y: v.y / length,
    z: v.z / length,
  };
}
```

```tsx
> normalize({x: 3, y:4, z:5})
//{
//  "x": 0.6,
//  "y": 0.8,
//  "z": 1
//}
```

- z 값이 무시되어 기대하지 않은 결과값이 반환됨.
- calculateLength는 Vector2D 을 받게 되어있으나 구조적으로 Vector3D와 호환되어 타입 체커가 문제로 인식하지 않음.
- 함수 작성시 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉬움. (봉인된 혹은 정확한 - sealed or precise 타입으로 불림)
- 그러나 타입스크립트 타입 시스템에서는 이를 제대로 표현할 수 없음. 이로인해 예상하지 못한 결과가 발생
