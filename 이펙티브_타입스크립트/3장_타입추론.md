# 3. 타입 추론

타입 추론에서 발생할 수 있는 몇가지 문제와 그 해법을 안내.

숙련자와 초보자의 차이는 타입 구문의 수에서 차이를 보임. (숙련자일수록 필요한 부분에만 사용)

## 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입스크립트의 많은 구문은 사실 불필요함.

다음과 같이 코드의 모든 변수에 타입을 선언하는 것은 비생산적이며 형편없는 스타일로 여겨짐

```tsx
let x: number = 12;
```

```tsx
//이정도로 하여도 충분함
let x = 12;
```

- 편집기를 통해 확인하면 이미 타입이 number로 추론되어 있음.

```tsx
const person: {
  name: string;
  born: {
    where: string;
    when: string;
  };
  died: {
    where: string;
    when: string;
  } = {
    name: "Sojourner Truth",
    born: {
      where: "Swartekill, NY",
      when: "c.1797",
    },
    died: {
      where: "Battle Creek, MI",
      when: "Nov. 26, 1883",
    },
  };
};
```

- 타입 선언이 위와 같을때 타입을 생략하고 작성해도 충분함.

```tsx
//타입 생략 버전
const person = {
  name: "Sojourner Truth",
  born: {
    where: "Swartekill, NY",
    when: "c.1797",
  },
  died: {
    where: "Battle Creek, MI",
    when: "Nov. 26, 1883",
  },
};
```

- 두 예제에서 Person의 타입은 동일함.
- 값에도 추가로 타입을 작성하는 것은 거추장스러움

```tsx
function square(nums: number[]) {
  return nums.map((x) => x * x);
}
const squares = square([1, 2, 3, 4]); // 타입은 number[]
```

- 배열의 경우도 객체와 마찬가지로, 타입스크립트는 입력받아 연산을 하는 함수가 어떤 타입을 반환하는지 정확히 알고 있음.

```tsx
const axis1: string = "x"; //타입은 string
const axis2 = "y"; //타입은 "y"
```

- axis2 변수를 string으로 예상하기 쉽지만 타입스크립트가 추론한 “y”가 더 정확한 타입.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

- 타입 추론이되면 리팩터링 역시 하기 쉬움

```tsx
interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  //Type 'string' is not assignable to type 'number'.
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}
```

- id에 문자도 들어올 수 있음을 나중에 알게되었다고 가정.
- 그래서 Product내의 id의 타입을 변경. logProduct내의 id 변수 선언에 있는 타입과 맞지 않기 때문에 오류가 발생
- 만약 logProduct 함수 내의 명시적 타입 구분이 없었다면, 코드는 아무런 수정 없이도 타입 체커를 통과했을것.

```tsx
function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

- logProduct는 비구조화 할당문을 사용해 구현하는게 나음.

```tsx
function logProduct(product: Product) {
  const { id, name, price }: { id: string; name: string; price: number } =
    product;
  console.log(id, name, price);
}
```

- 여기에 추가적으로 명시적 타입 구문을 넣는다면 불필요한 타입 선언으로 인해 코드가 번잡해짐.

- 정보가 부족하여 타입스크립트가 스스로 타입을 판단하기 어려운 상황도 일부 있음.
- 그럴 때는 명시적 타입 구문이 필요함.
- logProduct 함수에서 매개변수 타입을 product로 명시한 경우가 그 예

- 어떤 언어들은 매개변수의 최종 사용처까지 참고하여 타입을 추론.
- 타입스크립트는 최종 사용처까지 고려하지 않음.
- 타입스크립트에서 변수의 타입은 일반적으로 처음 변수가 등장할 때 결정.

- 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함
- 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않음.
- 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 함.

e.g : 간혹 함수 매개변수에 타입 구문을 생략하는 경우

```tsx
function parseNumber(str: string, base = 10) {
  //...
}
```

- 여기서 기본값이 10이므로 타입은 number로 추론됨.

```tsx
//anti-pattern
app.get("/health", (request: express.Request, response: express.Response) => {
  response.send("OK");
});

// good-pattern
app.get("/health", (request, response) => {
  response.send("OK");
});
```

- 보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론됨.
- request, response의 타입 선언은 필요하지 않음.

```tsx
const elmo: Product = {
  name: "Tickle Me Elmo",
  id: "048188 627152",
  price: 28.99,
};
```

- 타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 몇가지 상황 중 하나는 객체 리터럴을 정의할 때.
- 이런 정의에 타입을 명시하면, 잉여 속성 체크가 동작
- 잉여 속성 체크는 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적.
- 변수가 사용되는 순간이 아닌 할당하는 시점에 오류가 표시되도록 해줌.

```tsx
const furby = {
  name: "Furby",
  id: 635045681526,
  price: 28.99,
};
logProduct(furby);
//error
/*
Argument of type '{ name: string; id: number; price: number; }' is not assignable to parameter of type 'Product'.
  Types of property 'id' are incompatible.
    Type 'number' is not assignable to type 'string'.
*/
```

- 만약 타입 구문을 제거한다면 잉여 속성 체크가 동작하지 않고, 객체를 선언한 곳이 아니라 객체가 사용되는 곳에서 타입 오류가 발생

- 함수의 반환에도 타입을 명시하여 오류를 방지할 수 있음.
- 타입 추론이 가능할지라도 구현상의 오류가 함수를 호출한 곳 까지 영향을 미치지 않도록 하기 위해 타입 구문을 명시하는게 좋음.

```tsx
//주식 시세를 조회하는 함수를 작성했다고 가정
function getQuote(ticker: string) {
  return fetch(`https://quotes.example.com/?q=${ticker}`).then((response) =>
    response.json()
  );
}
```

```tsx
//이미 조회한 종목을 다시 요청하지 않도록 캐시를 추가함.
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string) {
  if (ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then((response) => response.json())
    .then((quote) => {
      cache[ticker] = quote;
      return quote;
    });
}
```

- 이 코드에는 오류가 있음.
- getQuote는 항상 Promise를 반환하므로 if 구문에는 cache[ticker]가 아니라 Promise.resolve(cache[ticker])가 반환되도록 해야함.

```tsx
getQuote("MSFT").then(considerBuying);
//error
//Property 'then' does not exist on type 'number | Promise<any>'.
//  Property 'then' does not exist on type 'number'
```

- 실행해 보면 오류는 getQuote 내부가 아닌 getQuote를 호출한 코드에서 발생.

```tsx
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string): Promise<number> {
  if (ticker in cache) {
    return cache[ticker];
    //error
    //Type 'number' is not assignable to type 'Promise<number>'.
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then((response) => response.json())
    .then((quote) => {
      cache[ticker] = quote;
      return quote;
    });
}
```

- 의도된 반환 타입(Promise<number>)을 명시한다면, 정확한 위치에 오류가 표시됨.

- 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않음
- Promise와 관련된 특정 오류를 피하는 데는 async 함수가 효과적

반환 타입을 명시해야하는 이유

- 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있기 때문
- 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야함.
- 추후에 코드가 조금 변경되어도 그 함수의 시그니처는 쉽게 바뀌지 않음.
- 미리 타입을 명시하는 방법은, 함수를 구현하기 전에 테스트를 먼저 작성하는 테스트 주도 개발(TDD)와 비슷함.
- 전체 타입 시그니처를 먼저 작성하면 구현에 맞추어 주먹구구식으로 시그니처가 작성되는 것을 방지하고 제대로 원하는 모양을 얻게됨.
- 반환 타입을 명시하면 더욱 직관적인 표현이 됨.

```tsx
interface Vector2D {
  x: number;
  y: number;
}
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y };
}
```

- 타입 스크립트는 해당 코드의 반환 타입을 {x: number, y:number} 로 추론.
- 이 경우 Vector2D와 호환되지만, 입력이 Vector2D인데 반해 출력은 Vector2D가 아니기 때문에 유저 입장에서는 당황스러움
- 이때 반환 타입을 명시하면 더욱 직관적인 표현이 됨.
- 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 잓어할 수 있어서 더욱 자세한 설명이 가능.
- 린터를 사용하고 있다면 eslint 규칙 중 no-inferrable-types 사용하여 모든 타입 구문이 정말로 필요한건지 확인 가능

요약

- 타입스크립트가 타입을 추론할 수 잇다면 타입 구문을 작성하지 않는게 좋음.
- 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없음.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환 타입에는 타입 명시를 고려해야함. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지함.

## 20. 다른 타입에는 다른 변수 사용하기

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 됨.

```tsx
let id = "12-34-56";
fetchProduct(id); // string으로 사용
id = 123456;
fetchProductBySerialNumber(id); // number로 사용
```

```tsx
//typescript 코드
let id = "12-34-56";
fetchProduct(id);

//Error - Type 'number' is not assignable to type 'string'.
id = 123456;
fetchProductBySerialNumber(id);
```

- 타입스크립트는 “12-34-56”이라는 값을 보고 id의 타입을 string으로 추론. string타입에는 number 타입을 할당할 수 없으므로 오류 발생
- 변수의 값은 바뀔 수 있지만, 그 타입은 보통 바뀌지 않는다는 관점을 알 수 있음.
- 타입을 바꿀 수 있는 한가지 방법은 범위를 좁히는 것. 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 적게 제한하는것.

```tsx
//에러를 수정한 코드
let id: string | number = "12-34-56";
fetchProduct(id);
id = 123456; //정상
fetchProductBySerialNumber(id); //정상
```

- 타입스크립트는 첫 번째 함수 호출에서 id는 string으로, 두 번째 호출에서는 number라고 제대로 판단.
- 할당문에서 유니온 타입으로 범위가 좁혀졌기 때문.

```tsx
const id = "12-34-56";
fetchProduct(id);

const serial = 123456; //정상
fetchProductBySerialNumber(serial); //정상
```

- 유니온 타입으로 코드는 동작하기는 하겠지만, 더 많은 문제가 생길 수 있으.ㅁ
- id를 사용할 때 마다 값이 어떤 타입인지 확인해야 하기 때문에 유니온 타입은 string, number같은 간단한 타입에 비해 다루기 더 어려움.
- 차라리 별도의 변수를 도입하는것이 더 나음.

다른 타입에는 별도의 변수를 상용하는게 바람직한 이유

- 서로 관련이 없는 두 개의 값을 분리(id와 serial).
- 변수명을 더 구체적으로 지을 수 있음.
- 타입 추론을 향상시키며, 타입 구문이 불필요해짐.
- 타입이 좀 더 간결해짐(string|number 대신 string과 number를 사용).
- let 대신 const로 변수를 선언하게 됨. 코드가 간결해지고 타입 체커가 타입을 추론하기에도 좋음.

e.g 가려지는 변수(shadowed)

```tsx
const id = "12-34-56";
fetchProduct(id);

{
  const id = 123456; //정상
  fetchProductBySerialNumber(id); //정상
}
```

- 여기서는 두 id는 이름이 값지만 실제로는 서로 아무 관련이 없음.
- 타입스크립트 코드는 잘 동작하겠으나, 사람에게 혼란을 줄 수 있음.
- 목적이 다른 곳에는 별도의 변수명을 사용하기 바람.
- 대다수의 개발팀이 린터 규칙을 통해 ‘가려지는’ 변수를 사용하지 못하도록함.

요약

- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않음.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록함.

## 21. 타입 넓히기

타입 스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 가능한 값들의 집합인 타입을 가짐.

상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야함.

지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야함.

타입 스크립트에서는 이러한 과정을 넓히기(widening)이라고 부름.

→ 넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있음.

```tsx
//벡터를 다루는 라이브러리 코드 가정
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
  return vector[axis];
}
```

- Vector3함수를 사용한 다음 코드는 런타임에 오류 없이 실행

```tsx
let x = "x";
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x);
//Error - Argument of type 'string' is not assignable to parameter of type '"x" | "y" | "z"'.
```

- 그러나 편집기에서 오류 표시
- getComponent함수는 두 번째 매개변수에 “x” | “y” | “z” 을 기대했지만 x의 타입은 할당 시점에 넓히기가 동작해서 string으로 추론.
- string 타입은 “x” | “y” | “z” 타입에 할당이 불가능하므로 오류가 된 것.
- 타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 상당히 모호.

```tsx
const mixed = ["x", 1];
```

- mixed 의 타입이 될 수 있는 후보군
  - (’x’ | 1)[]
  - [’x’, 1]
  - [string, number]
  - readonly [string, number]
  - (string|number)[]
  - readonly (string|number)[]
  - [any, any]
  - any[]
- 정보가 충분하지 않다면 mixed가 어떤 타입으로 추론되어야 하는지 알 수 없음.
- 그러므로 타입 스크립트는 작성자의 의도를 추측(이 경우 (string|number)[]으로 추측)
- 그러나 타입스크립트가 아무리 영리하더라도 사람의 마음까지 읽ㅇ르 수 없고, 따라서 추측한 답이 항상 옳을 수도 없음.

```tsx
let x = "x";
x = "a";
x = "Four asdf asdfewer";
```

- 타입 스크립트는 다음 예제와 같은 코드를 예상했기 때문에 x의 타입을 string으로 추론.

```tsx
let x = "x";
x = /x|y|z/;
x = ["x", "y", "z"];
```

- 자바스크립트는 위와 같이 작성해도 유효함.
- 타입스크립트는 x의 타입을 string으로 추론할 때, 명확성과 유연성 사이의 균형을 유지하려고함.
- 일반적인 규칙은 변수가 선언된 후로는 타입이 바뀌지 않아야하므로 string|RegExp나 string|string[] 이나 any보다는 string을 사용하는게 나음.

```tsx
//오류 해결
const x = "x"; //타입이 "x"
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); //정상
```

- 타입스크립트는 넓히기의 과정을 제어할 수 있도록 몇가지 방법을 제공
- 넓히기 과정을 제어할 수 있는 첫 번째 방법은 const
- 만약 let 대신 const로 변수를 선언하면 더 좁은 타입이 됨.
- 이제 x는 재할당될 수 없으므로, 타입스크립트는 의심의 여지 없이 더 좁은 타입(”x”)으로 추론할 수 있음.
- 문자 리터럴 타입 “x”는 “x”|”y”|”z”에 할당 가능하므로 코드가 타입 체커를 통과함.

- 그러나 const는 만능이 아님. 객체와 배열의 경우에는 여전히 문제가 있음.
- 아이템 초반에 있는 mixed 예제(const mixed = [’x’, 1];)는 배열에 대한 문제를 보여줌
- 튜플 타입을 추론해야할 지, 요소들은 어떤 타입으로 추론해야 할지 알 수 없음.
- 비슷한 문제가 객체에도 발생.

```tsx
//자바스크립트는 정상으로 처리
const v = {
  x: 1,
};
v.x = 3;
v.x = "3";
v.y = 4;
v.name = "Pythagoras";
```

- v의 타입은 구체적인 정도에 따라 다양한 모습으로 추론될 수 있음
- 가장 구체적인 경우라면 {readonly x:1}
- 추상적으로는 {x:number}, {[key: string] number} 또는 object
