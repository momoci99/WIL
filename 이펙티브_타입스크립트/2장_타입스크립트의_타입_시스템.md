# 2장 타입스크립트의 시스템

## 편집기를 사용하여 타입시스템 탐색

- 편집기(VS Code or Visual Studio)에서 타입 스크립트 언어를 적극 활용
- 편집기 사용시 타입시스템, 타입스크립트가 타입을 추론하는 개념을 알 수 있음.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기위해 타입 선언 파일을 찾아보는 방법 숙지.

## 타입이 값들의 집합이라고 생각하기

- 변수에는 다양한 종류의 값을 할당할 수 있음
- 타입스크립트는 오류를 체크하는 순간에는 타입을 가지고 있음.
- 타입을 `할당 가능한 값들의 집합(혹은 범위)` 이라고 생각하면 됨.

e.g

- 42와 37.5는 `number` 타입.
- ‘Canada’ 는 `string` 타입.
- null과 undefined는 `strictNullChecks` 플래그 사용 여부에 따라 number에 해당 될 수도, 아닐 수도 있음.

**공집합 타입 never**

- 타입스크립트의 가장 작은 집합은 `nerver` 이며 아무 값도 포함하지 않는 공집합.

**유닛(unit) 타입 혹은 리터릴(literal)타입**

- never 다음으로 작은 타입. 한가지 값만 포함하고 있음.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
```

**두개 혹은 세개로 묶으려면 유니온(union)타입을 사용**

```typescript
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 세개 이상의 타입을 묶을때로 동일하게 | 로 이어주면 됨.

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/ae66a753-db64-4b26-9c4c-db3d7e846810/Untitled.png)

- ‘C’는 유닛 타입으로서, 범위는 단일값 `"C"` 구성. 따라서 AB(”A”와 “B”로 이루어진) 부분집합이 아니므로 오류 발생
- 집합의 관점에서 타입체커의 역할은 하나의 집합이 다른 집합의 부분집합인지 검사하는것.
- declare 설명 : https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f742c95a-eab9-4c34-b662-d76dd7a87f44/Untitled.png)

- AB12는 AB의 부분집합이 될 수 없으므로 에러 발생.

e.g

```ts
type Int = 1 | 2 | 3 | 4 | 5; // | ..

interface Identified {
  id: string;
}
```

- 범위가 무한대인 경우 원소를 일일이 추가(첫번째)하는 방법도 있겠으나 원소를 서술(두번째)
- 어떤 객체가 string으로 할당가능한 id 속성을 가지고 있다면 그 객체는 Identified 타입으로 볼 수 있음.
- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성을 가질 수 있음을 의미.
- 함수 호출의 매개변수에서도 다른 속성을 가질 수 있음.
- 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(express property checking : [링크](https://dev.to/this-is-learning/understanding-excess-property-checking-in-typescript-ook))만 생각하다보면 간과하기 쉬움

### & 연산자 - 인터섹션(intersection)

e.g

```typescript
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

- `&` 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산함.
- 겉으로 보았을 때, Person과 Lifespan 인터페이스는 공통 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬움.
- 그러나 타입 연산자는 인터페이스의 속성이 아닌 값의 집합(타입의 범위)에 적용.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/2aa7f076-3ab6-4150-9a21-c3ee431ee0ac/Untitled.png)

- 그래서 Person과 Lifespan을 둘다 가지는 값은 인터섹션 타입에 속하게됨.
- 인터섹션 타입의 값은 각 타입 내의 모든 속성을 포함하는 것이 일반적.
