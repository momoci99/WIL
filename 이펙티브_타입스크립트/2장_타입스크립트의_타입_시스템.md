# 2장 타입스크립트의 시스템

## 편집기를 사용하여 타입시스템 탐색

- 편집기(VS Code or Visual Studio)에서 타입 스크립트 언어를 적극 활용
- 편집기 사용시 타입시스템, 타입스크립트가 타입을 추론하는 개념을 알 수 있음.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기위해 타입 선언 파일을 찾아보는 방법 숙지.

## 타입이 값들의 집합이라고 생각하기

- 변수에는 다양한 종류의 값을 할당할 수 있음
- 타입스크립트는 오류를 체크하는 순간에는 타입을 가지고 있음.
- 타입을 `할당 가능한 값들의 집합(혹은 범위)` 이라고 생각하면 됨.

e.g

- 42와 37.5는 `number` 타입.
- ‘Canada’ 는 `string` 타입.
- null과 undefined는 `strictNullChecks` 플래그 사용 여부에 따라 number에 해당 될 수도, 아닐 수도 있음.

**공집합 타입 never**

- 타입스크립트의 가장 작은 집합은 `nerver` 이며 아무 값도 포함하지 않는 공집합.

**유닛(unit) 타입 혹은 리터릴(literal)타입**

- never 다음으로 작은 타입. 한가지 값만 포함하고 있음.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
```

**두개 혹은 세개로 묶으려면 유니온(union)타입을 사용**

```typescript
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 세개 이상의 타입을 묶을때로 동일하게 | 로 이어주면 됨.

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/ae66a753-db64-4b26-9c4c-db3d7e846810/Untitled.png)

- ‘C’는 유닛 타입으로서, 범위는 단일값 `"C"` 구성. 따라서 AB(”A”와 “B”로 이루어진) 부분집합이 아니므로 오류 발생
- 집합의 관점에서 타입체커의 역할은 하나의 집합이 다른 집합의 부분집합인지 검사하는것.
- declare 설명 : https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f742c95a-eab9-4c34-b662-d76dd7a87f44/Untitled.png)

- AB12는 AB의 부분집합이 될 수 없으므로 에러 발생.

e.g

```ts
type Int = 1 | 2 | 3 | 4 | 5; // | ..

interface Identified {
  id: string;
}
```

- 범위가 무한대인 경우 원소를 일일이 추가(첫번째)하는 방법도 있겠으나 원소를 서술(두번째)
- 어떤 객체가 string으로 할당가능한 id 속성을 가지고 있다면 그 객체는 Identified 타입으로 볼 수 있음.
- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성을 가질 수 있음을 의미.
- 함수 호출의 매개변수에서도 다른 속성을 가질 수 있음.
- 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(express property checking : [링크](https://dev.to/this-is-learning/understanding-excess-property-checking-in-typescript-ook))만 생각하다보면 간과하기 쉬움

### & 연산자 - 인터섹션(intersection)

e.g

```typescript
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

- `&` 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산함.
- 겉으로 보았을 때, Person과 Lifespan 인터페이스는 공통 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬움.
- 그러나 타입 연산자는 인터페이스의 속성이 아닌 값의 집합(타입의 범위)에 적용.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/2aa7f076-3ab6-4150-9a21-c3ee431ee0ac/Untitled.png)

- 그래서 Person과 Lifespan을 둘다 가지는 값은 인터섹션 타입에 속하게됨.
- 인터섹션 타입의 값은 각 타입 내의 모든 속성을 포함하는 것이 일반적.

### **| 연산자 - 유니온(Union)**

e.g

```ts
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 값들의 합집합을 뜻함.
- 세개 이상의 타입을 묶을때도 `|` 로 이어줄 수 있음.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/a0d59c34-ce25-40e5-87f0-c128b424a476/Untitled.png)

- 두 인터페이스 Person 과 Lifespan의 유니온은 `never` .

e.g

- 인터섹션과 유니온 연산에 대해서는 아래의 수식이 성립

```ts
keyof (A & B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

_여기서 keyof 는 오브젝트(타입, 인터페이스 포함)의 키값을 추출하여 union형태로 반환하는 연산자_

e.g

- 일반적으로 위에서 정의한 `PersonSpan` 을 정의할때는 `extends` 사용

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

- 타입이 집합이라는 관점하에 `extends`의 의미는 “~에 할당가능한 과 비슷하게” ,” ~의 부분집합이라는 의미로 받아들일 수 있음.
- `PersonSapn` 타입의 모든 값은 문자열 name 속성을 가져야함.
- 그리고 birth 속성을 가져야 제대로 된 부분 집합이 됨.

e.g

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D extends Vector1D {
  y: number;
}
interface Vercotr3D extends Vector2D {
  z: number;
}
```

- 어떤 집합이 다른 집합의 부분 집합일 때 ‘서브 집합’ 이라고 칭함.
- Vector3D는 Vector2D의 서브타입.
- Vector2D는 Vector1D의 서브타입.

e.g

extends키워드 없이 동일하게 인터페이스를 작성한다면 아래와 같음

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D {
  x: number;
  y: number;
}
interface Vercotr3D {
  x: number;
  y: number;
  z: number;
}
```

- 집합은 바뀌지 않음.
- 두 스타일 모두 객체 타입에 대해서 잘 동작하나, 리터럴 타입과 유니온 타입을 생각해 본다면, 집합 스타일이 더 직관적.
- extends 키워드는 제너릭 타입에서 한정자로도 쓰임 (~의 부분집합의 의미)

```ts
function getKey<K extends string>(val: any, key: K) {
  //...
}
```

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; //타입은 "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  //...
}

const pts: Point[] = [
  { x: 1, y: 1 },
  { x: 2, y: 0 },
];
soryBy(pts, "x"); //정상, 'x'는 'x' | 'y'를 상속 (즉 keyof T)
soryBy(pts, "y"); //정상, 'y'는 'x' | 'y' 를 상속
soryBy(pts, Math.random() < 0.5 ? "x" : "y"); //정상, 'x' | 'y' 는 'x' | 'y' 를 상속
soryBy(pts, "z"); //error : "z" 형식의 인수는 'x' | 'y' 형식의 매개변수에 할당될 수 없음.
```
