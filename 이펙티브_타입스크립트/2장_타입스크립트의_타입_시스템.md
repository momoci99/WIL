# 2장 타입스크립트의 시스템

## 편집기를 사용하여 타입시스템 탐색

- 편집기(VS Code or Visual Studio)에서 타입 스크립트 언어를 적극 활용
- 편집기 사용시 타입시스템, 타입스크립트가 타입을 추론하는 개념을 알 수 있음.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기위해 타입 선언 파일을 찾아보는 방법 숙지.

## 타입이 값들의 집합이라고 생각하기

- 변수에는 다양한 종류의 값을 할당할 수 있음
- 타입스크립트는 오류를 체크하는 순간에는 타입을 가지고 있음.
- 타입을 `할당 가능한 값들의 집합(혹은 범위)` 이라고 생각하면 됨.

e.g

- 42와 37.5는 `number` 타입.
- ‘Canada’ 는 `string` 타입.
- null과 undefined는 `strictNullChecks` 플래그 사용 여부에 따라 number에 해당 될 수도, 아닐 수도 있음.

**공집합 타입 never**

- 타입스크립트의 가장 작은 집합은 `nerver` 이며 아무 값도 포함하지 않는 공집합.

**유닛(unit) 타입 혹은 리터릴(literal)타입**

- never 다음으로 작은 타입. 한가지 값만 포함하고 있음.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
```

**두개 혹은 세개로 묶으려면 유니온(union)타입을 사용**

```typescript
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 세개 이상의 타입을 묶을때로 동일하게 | 로 이어주면 됨.

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/ae66a753-db64-4b26-9c4c-db3d7e846810/Untitled.png)

- ‘C’는 유닛 타입으로서, 범위는 단일값 `"C"` 구성. 따라서 AB(”A”와 “B”로 이루어진) 부분집합이 아니므로 오류 발생
- 집합의 관점에서 타입체커의 역할은 하나의 집합이 다른 집합의 부분집합인지 검사하는것.
- declare 설명 : https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f742c95a-eab9-4c34-b662-d76dd7a87f44/Untitled.png)

- AB12는 AB의 부분집합이 될 수 없으므로 에러 발생.

e.g

```ts
type Int = 1 | 2 | 3 | 4 | 5; // | ..

interface Identified {
  id: string;
}
```

- 범위가 무한대인 경우 원소를 일일이 추가(첫번째)하는 방법도 있겠으나 원소를 서술(두번째)
- 어떤 객체가 string으로 할당가능한 id 속성을 가지고 있다면 그 객체는 Identified 타입으로 볼 수 있음.
- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성을 가질 수 있음을 의미.
- 함수 호출의 매개변수에서도 다른 속성을 가질 수 있음.
- 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(express property checking : [링크](https://dev.to/this-is-learning/understanding-excess-property-checking-in-typescript-ook))만 생각하다보면 간과하기 쉬움

### & 연산자 - 인터섹션(intersection)

e.g

```typescript
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

- `&` 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산함.
- 겉으로 보았을 때, Person과 Lifespan 인터페이스는 공통 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬움.
- 그러나 타입 연산자는 인터페이스의 속성이 아닌 값의 집합(타입의 범위)에 적용.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/2aa7f076-3ab6-4150-9a21-c3ee431ee0ac/Untitled.png)

- 그래서 Person과 Lifespan을 둘다 가지는 값은 인터섹션 타입에 속하게됨.
- 인터섹션 타입의 값은 각 타입 내의 모든 속성을 포함하는 것이 일반적.

### **| 연산자 - 유니온(Union)**

e.g

```ts
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 값들의 합집합을 뜻함.
- 세개 이상의 타입을 묶을때도 `|` 로 이어줄 수 있음.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/a0d59c34-ce25-40e5-87f0-c128b424a476/Untitled.png)

- 두 인터페이스 Person 과 Lifespan의 유니온은 `never` .

e.g

- 인터섹션과 유니온 연산에 대해서는 아래의 수식이 성립

```ts
keyof (A & B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

_여기서 keyof 는 오브젝트(타입, 인터페이스 포함)의 키값을 추출하여 union형태로 반환하는 연산자_

e.g

- 일반적으로 위에서 정의한 `PersonSpan` 을 정의할때는 `extends` 사용

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

- 타입이 집합이라는 관점하에 `extends`의 의미는 “~에 할당가능한 과 비슷하게” ,” ~의 부분집합이라는 의미로 받아들일 수 있음.
- `PersonSapn` 타입의 모든 값은 문자열 name 속성을 가져야함.
- 그리고 birth 속성을 가져야 제대로 된 부분 집합이 됨.

e.g

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D extends Vector1D {
  y: number;
}
interface Vercotr3D extends Vector2D {
  z: number;
}
```

- 어떤 집합이 다른 집합의 부분 집합일 때 ‘서브 집합’ 이라고 칭함.
- Vector3D는 Vector2D의 서브타입.
- Vector2D는 Vector1D의 서브타입.

e.g

extends키워드 없이 동일하게 인터페이스를 작성한다면 아래와 같음

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D {
  x: number;
  y: number;
}
interface Vercotr3D {
  x: number;
  y: number;
  z: number;
}
```

- 집합은 바뀌지 않음.
- 두 스타일 모두 객체 타입에 대해서 잘 동작하나, 리터럴 타입과 유니온 타입을 생각해 본다면, 집합 스타일이 더 직관적.
- extends 키워드는 제너릭 타입에서 한정자로도 쓰임 (~의 부분집합의 의미)

```ts
function getKey<K extends string>(val: any, key: K) {
  //...
}
```

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; //타입은 "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  //...
}

const pts: Point[] = [
  { x: 1, y: 1 },
  { x: 2, y: 0 },
];
sortBy(pts, "x"); //정상, 'x'는 'x' | 'y'를 상속 (즉 keyof T)
sortBy(pts, "y"); //정상, 'y'는 'x' | 'y' 를 상속
sortBy(pts, Math.random() < 0.5 ? "x" : "y"); //정상, 'x' | 'y' 는 'x' | 'y' 를 상속
sortBy(pts, "z"); //error : "z" 형식의 인수는 'x' | 'y' 형식의 매개변수에 할당될 수 없음.
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/88cf55fc-6b26-4f5a-ae57-5c4bed1c4261/Untitled.png)

- 타입들이 엄격한 상속 관계가 아닐 때는 집합 스타일이 더 바람직함.
- string | Number와 string | Date 의 인터섹션 (`&`) 은 공집합이 아니며 (이때는 string) 서로의 부분 집합도 아님.
- 타입들이 엄격한 상속 관계가 아니더라도 범위에 대한 관계는 명확함 (그림참조)

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f6b897c4-76cc-4cf4-8578-d9e58b15bba0/Untitled.png)

- 타입이 집합이라는 관점은 위의 예를 통해 명확히 알 수 있음.
- 위 코드에서 숫자 배열을 숫자들의 쌍(pair)라고는 할 수 없음. 빈 리스트와 [1]이 그 반례
- number[]는 [number, number]의 부분 집합이 아니므로 할당할 수 없음(반대로 할당시 동작함)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/11615347-78fe-4e11-9731-f6f3f26cb620/Untitled.png)

- 동일한 이유로 위의 코드는 동작하지 않음.
- 타입이 값의 집합이라는 의미는 동일한 값의 집합을 가지는 두 타입은 같다는 의미.
- 만약, 두 타입이 의미적으로 다르고 우연히 같은 범위를 가진다 하여도 같은 타입을 두번 정의할 필요는 없음.

e.g

```tsx
// 타입은 Date
// string | Date 와 string | number의 인터섹션 타입중 string을 string | Date 에서 제외
// 그러므로 타입은 Date
type T = Exclude<string | Date, string | number>;

//타입은 여전히 number
type NonZeroNums = Exclude<number, 0>;
```

- 타입 스크립트 타입이 되지 못하는 값의 집합들이 있다는것을 기억해야함.
- 예제처럼 Exclude를 사용해서 일부 타입을 제외할 수는 있으나, 그 결과가 적절한 타입스크립트 타입일 때만 유효함

| 타입 스크립트 용어           | 집합 용어                                        |     |
| ---------------------------- | ------------------------------------------------ | --- |
| nerver                       | Ø(공집합)                                        |
| 리터럴 타입                  | 원소가 1개인 집합                                |
| 값이 T에 할당 가능           | 값 ∈ T (값이 T의 원소)                           |
| T1이 T2에 할당가능           | T1 ⊆ T2 (T1이 T2의 부분 집합)                    |
| T1이 T2를 상속               | T1 ⊆ T2 (T1이 T2의 부분 집합)                    |
| T1                           | T2 (T1과 T2의 유니온) T1 ∪ T2 (T1과 T2의 합집합) |
| T1 & T2 (T1과 T2의 인터섹션) | T1 ∩ T2 (T1과 T2의 교집합)                       |
| unknown                      | 전체(universal) 집합                             |

요약

- 타입을 값의 집합으로 생각하면 이해하기 쉬움(타입의 범위)
- 이 집합은 유한(boolean 또는 리터럴)하거나 무한(number 또는 string)함.
- 타입스크립트는 엄격한 상속관계가 아니라 겹쳐지는 집합(밴 다이어 그램)으로 표현.
- 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있음.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있음.
- 타입 연산은 집합의 범위에 적용. A와 B의 인터섹션(&) 은 A와 B의 범위의 인터섹션.
- 객체타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미함.
- ‘A는 B를 상속’, ‘A는 B에 할당 가능’, ‘A는 B의 서브타입’ 은 ‘A는 B의 부분 집합’ 과 같은 의미.

## 타입 공간과 값을 공간의 심벌 구분하기.

e.g

```tsx
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

- interface Cylinder에서 Cylinder는 타입으로 쓰임.
- const Cylinder에서 Cylinder와 이름은 같으나 값으로 쓰이며, 서로 아무 관련도 없음.
- 상황에 따라 Cylinder는 타입으로 쓰이거나, 값으로 쓰일 수 있음.
- 이런 부분이 가끔 오류를 야기함.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/a6cc1e40-7151-468d-9376-b3ba3aacf475/Untitled.png)

- instanceof를 이용하여 shape가 Cylinder 타입인지 체크를 시도.
- 그러나 instanceof는 런타임 연산자이며 값에 대한 연산만 수행.
- 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조.

e.g

```tsx
type T1 = "string literal";
type T2 = 123;
const v1 = "string literal";
const v2 = 123;
```

- 일반적으로 type이나 interface 다음에 나오는 심벌은 타입.
- const, let 다음에 나오는 심벌은 값.

e.g

```tsx
//type T1 = 'string literal';
//type T2 = 123;
//const v1 = 'string literal';
//const v2 = 123;

//타입 선언은 컴파일 후 사라진다.
"use strict";
const v1 = "string literal";
const v2 = 123;
```

- 컴파일 후 심벌이 사라진다면 타입에 해당됨.

e.g

```tsx
class Cylinder {
  radius = 1;
  height = 1;
}

function caculatorVolume(shape: unknow) {
  if (shape instanceof Cylinder) {
    shape; //정상. 타입은 Cylider
    shape.radius; //정상 타입은 number
  }
}
```

- class와 enum은 상황에 따라 타입과 값 두가지 모두 가능한 예약어
- 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용됨.
- 반면 값으로 쓰일때는 생성자가 사용됨.

```tsx
interface Person {
  first: string;
  last: string;
}

const p: Person = { first: "Jane", last: "Jacobs" };

function email(p: Person, subject: string, body: string): Response {}

type T1 = typeof p; //타입은 Person
type T2 = typeof email; //타입은 (p: Person, subject:string, body:string):Response

const v1 = typeof p; // 값은 "object"
const v2 = typeof email; //값은 "function"
```

- 타입의 관점에서 typeof는 값을 읽어서 타입스크립트 타입을 반환.
- 타입의 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있음.
- 혹은 type 구문으로 이름을 붙이는 용도로 사용할 수 있음.

javascript의 typeof

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof

- 값의 관점에서 typeof는 자바스크립트 런타임의 typeof연산자가 됨.
- 값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환.
- 타입스크립트와는 다름.
- 자바스크립트의 런타임 타입 시스템은 타입스크립트의 정적 타입시스템보다 훨씬 간단하게 동작.

타입스크립트 타입의 종류에 비해 자바스크립트는 지금까지 단 7개가 존재(책에서는 6개지만 현재 js스펙이 올라가면서 7개로 변경됨) (string, number, boolean, undefined, object, function, symbol)

- 자바스크립트의 기본 타입
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures

- 타입스크립트에서의 typeof 설명

- class키워드는 값과 타입 두가지로 모두 사용됨.
- 따라서 클래에 대한 typeof는 상황에 따라 다르게 동작함.

```ts
const v = typeof Cylinder; //값이 "function"
type T = typeof Cylinder; //타입이 typeof Cylinder
```

- 클래스는 자바스크립트에서 실제 함수로 구현되므로 첫번째 줄의 값은 “function”이 됨.
- Cylinder가 인스턴스의 타입이 아니라는 점에 주목.

```ts
declare let fn: T;
const c = new fn(); //타입이 Cylinder
```

- 실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수.

```ts
type C = InstanceType<typeof Cylinder>; //타입이 Cylinder
```

- InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환가능.

```ts
const first: Person["first"] = p["first"]; //또는 p.first
```

- 속성 접근자인 []는 타입으로 쓰일 때에도 동일하게 동작함.
- 그러나 obj[’field’] 와 obj.field는 값이 동일하더라도 타입은 다를 수 있음.
- 따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법(obj[’field’])를 사용해야함.
- Person[’first’]는 여기서 타입 맥락으로 사용되었으므로 타입.
- 인덱스 위치에는 유니온 타입과 기본형 타입을 포함한 어떤 타입이든 사용할 수 있음.

```ts
type PersonEl = Person["first" | "last"]; //타입은 string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // 타입 string | number | Date
```

속성 접근자에 대한 정리

**this**

- 값으로 쓰이는 this는 자바스크립트의 this의 키워드.
- 타입으로 쓰이는 this는 일명 다형성(polymorphic) this라고 불리는 this의 타입스크립트 타입.
- 서브클래스의 메서드 체인을 구현할 때 유용.

**& |**

- 값에서 & 와 | 는 AND 와 OR 비트연산자로 사용
- 타입에서는 인터섹션과 유니온

const

- const는 새 변수를 선언.
- as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 변경.

extends

- extends는 서브클래스(class A extends B)또는 서브타입(interface A extends B) 또는 제너릭 한정자(Generic<T extends number>)를 정의.

in

- 루프(for (key in object))또는 매핑된(mapped)타입에 등장.

타입 공간과 값 공간을 혼동하여 발생할 수 있는 케이스

```tsx
function email(options: { person: Person; subject: string; body: string }) {
  // ...
}
```

- 자바스크립트에서 객체 내 각 속성을 로컬 변수로 만들어주는 구조 분해 할당을 사용하여 위의 코드를 아래와 같이 변경

```tsx
function email ({person, subject, body}) //in javascript

//타입 스크립트에서는 아래 코드에 에러가 발생
function email({
	person:Person,
	subject:string,
	body: string}

}){
	//...
}
```

- 값의 관점에서 Person과 string이 해석되었으므로 에러가 발생하게됨.
- Person이라는 변수명과 string이라는 이름을 가지는 두개의 변수를 생성하려고 시도한것.
- 타입과 값을 구분하여 해결가능

```tsx
function email(
{person, subject, body} : {person: Person, subject:string, body:string} {
	//...
}
```

- 코드가 장황ㅎ하여도 매개변수에 명명된 타입을 사용하거나 문맥에서 추론하도록 잘 동작.

## 타입 단언보다는 타입 선언을 사용하기

```tsx
interface Person {
  name: string;
}

const alice: Person = { name: "Alice" }; //타입은 Person
const bob = { name: "Bob" } as Person; //타입은 Person
```

- 이 두가지 방법은 결과가 같아보이나 전혀 그렇지 않음.
- 첫번째 alice:Person은 변수에 ‘타입 선언’을 붙여서 그 값이 선언된 타입을 명시
- 두번째 as Person은 ‘타입 단언’ 을 수행. 타입스크립트가 이미 추론한 타입이 있더라도 Person 타입으로 간주함.
- 타입 단언보다 타입 선언을 사용하는게 더 나음.

```tsx
const alice: Person = {};
//~~~ 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
const bob = {} as Person; //오류 없음.
```

- 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사함.
- 이전의 예제는 그러지 못하였으므로 (alice 케이스) 타입스크립트가 오류를 표시.
- 타입 단언(bob 케이스)은 강제로 타입을 지정하였으므로 타입 체커에게 오류를 무시하라고 하는것.

```tsx
const alice: Person = {
  name: "Alice",
  occupation: "Typescript developer",
};

const bob = {
  name: "bob",
  occupation: "Javascript developer",
} as Person;
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/af315dee-6905-49d0-b123-a92e90404542/Untitled.png)

- 타입 선언문에는 잉여 속성 체크가 동작했으나, 단언문에는 적용되지 않음.
- 타입 단언이 꼭 필요한 경우가 아니라면 안전성 체크도 되는 타입 선언을 사용 권장

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있음.

```tsx
const people = ["alice", "bob", "jan"].map((name) => ({ name }));
//Persone[]을 원했으나 결과는 {name:string;}[]...

const people = ["alice", "bob", "jan"].map((name) => ({ name } as Person));
//타입은 Person[] 이겠으나 런타임에 문제발생
```

- 타입 단언을 사용하여 앞선 예제들처럼 런타임에 문제가 발생

```tsx
const people = ["alice", "bob", "jan"].map((name) => ({} as Person));
//오류 없음
```

개선 버전 1

```tsx
const people = ["alice", "bob", "jan"].map((name) => {
  const person: Person = { name };
  return person;
}); //타입은 Person[]
```

개선 버전 2

```tsx
const people = ["alice", "bob", "jan"].map((name): Person => ({ name }));
//타입은 Person[]
```

- (name):Person은 name의 타입이 없고, 반환 타입이 Person임을 명시.
- 그러나 (name: Person)은 name의 타입이 Person임을 명시하고 반환 타입이 없으므로 오류가 발생

개선 버전 3

```tsx
const people: Person[] = ["alice", "bob", "jan"].map(
  (name): Person => ({ name })
);
```

- 최종적으로 원하는 타입을 명시
- 타입스크립트가 할당문의 유효성을 검사하게함
- 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야함. 그래야 오류 표기가 정확해짐

타입 단언이 반드시 필요한 경우

```ts
document.querySelector("#myButton").addEventListener("click", (e) => {
  e.currentTarget; //타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button; //타입은 HTMLButtonElement;
});
```

- 타입스크립트는 DOM에 접근할 수 없으므로 #myButton이 버튼 엘리먼트인지 알지 못함.
- 이벤트의 currentTarget이 같은 버튼이여야하는것도 알지 못함.
- 타입스크립트가 알지 못하는 정보를 가지고 있으므로 타입 단언문을 사용하는것이 타당함.

타입 단정문 `!` - null이 아님을 단언하는 경우.

```tsx
const elNull = document.getElementById("foo"); //타입은 HTMLElement | null
const el = document.getElementBy("foo")!; //타입은 HTMLElement
```

- 변수의 접두사로 쓰인 !는 boolean의 부정문
- 그러나 접미사로 쓰인 !는 그 값이 null이 아니라는 단언문으로 해석됨.
- !를 일반적인 단언문처럼 생각해야하며 컴파일중에 제거됨.
- 타입 체커는 알기 어려우나, 그 값이 null이 아님을 확신할 수 있을 때 사용해야함.
- 그렇지 않은 경우 반드시 null인 경우를 체크하는 조건문을 사용해야함.

타입 단언문의 한계

```tsx
interface Person {
  name: string;
}
const body = document.body;
const el = body as Person;
//에러 발생
//Conversion of type 'HTMLElement' to type 'Person' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
//Property 'name' is missing in type 'HTMLElement' but required in type 'Person'.
```

- 타입 단언문으로 임의의 타입 간에 변환을 할 수 는 없음.
- A가 B의 부분집합인 경우에 타입 단언문을 사용해 변환할 수 있음.
- Person과 HTMLElement는 서로의 서브타입이 아니므로 변환이 불가능.
- 이 에러를 해결하고 싶다면 unknown을 활용해야함.

```tsx
const el = document.body as unknown as Person; //정상
```

- 모든 타입은 unknown의 서브타입이므로 unknown이 포함된 단언문은 항상 동작.
- unknown을 사용한 이상 적어도 개발자에게 위험한 동작을 하고 있음을 알림.

요약

- 타입 단언(as Type)보다 타입 선언(:Type)을 사용.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야함.
- 타입스크립트보다 타입 정보를 더 잘 알고있는 상황에서는 타입 단언문 혹은 null 아님 단정문(!) 사용.

## 객체 래퍼 타입 피하기

- 자바스크립트 기본 타입들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됨
- 그러나 기본형인 string인 경우 메서드를 가지고 있는것 처럼 보임.

```tsx
"primitive".charAt(3);
//"m":
```

- 사실 charAt은 string의 메서드가 아니며 string을 사용할 때 자바스크립트 내부에서 변환 과정이 일어남.
- string 기본형에는 메서드가 없고, 메서드를 가지는 String ‘객체’ 타입이 정의되어있음.
- 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환.
- string 기본형에 charAt 같은 메서드를 사용할 때, 자바스크립트는 기본형을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버림.

String.prototype을 몽키 패치하여 위의 설명을 관찰가능.

```tsx
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function (pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};
console.log("primitive".charAt(3));

//출력
//String {'primitive'} 'object' 3
//m
```

- 메서드 내의 this는 string기본형이 아닌 String객체 래퍼.
- String객체를 직접 생성 할 수 있으며, string 기본형처럼 동작.
- 그러나 string기본형과 String객체 래퍼가 항상 동일하게 동작하는것은 아님.

```tsx
"hello" === new String("hello");
false;
new String("hello") === new String("hello");
false;
```

- String객체는 오직 자기 자신만 동일하게 취급.

```tsx
let x = "hello";
x.language = "English";
("English");
x.language;
undefined;
```

- 객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보일 때가 있음.
- 어떤 속성을 기본형에 할당하면 해당 속성은 사라짐.
- 실제로는 x가 String객체로 변환 된 후 language속성이 추가되었고, language속성이 추가된 객체는 버려진것.

타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링

- string / String
- number / Number
- boolean / Boolean
- symbol / Symbol
- bingint / BigInt

- 그러나 string을 사용할 때는 특히 유의.
- string을 String이라고 잘못 타이핑 하기 쉬우며, 실수를 하더라도 처음에는 잘 동작하는것으로 보임.

```ts
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("hello");
getStringLen(new String("hello"));
//둘 다 정상 동작
```

- 그러나 string을 매개변수로 받는 메서드에 String 객체를 전달하는 순간 문제 발생

```tsx
function isGreeting(phrase: String) {
  return ["hello", "good day"].includes(phrase);
}

/*
 Argument of type 'String' is not assignable to parameter of type 'string'.
 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.
*/
```

- string은 String에 할당할 수 있지만 String은 string에 할당할 수 없음.
- 오류 메세지대로 string타입을 사용해야함.
- 대부분의 라이브러리와 마찬가지로 타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로 되어있음.

```ts
const s: String = "primitive";
const n: Number = 12;
const b: Boolean = true;
```

- 래퍼 객체는 타입 구문의 첫 글자를 대문자로 표기하는 방법으로도 사용할 수 있음.
- 당연히 런타임의 값은 객체가 아니고 기본형.
- 그러나 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용.
- 단, 기본형 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉽고, 굳이 그럴 필요도 없으므로 기본형 타입을 사용하는게 나음.

new 없이 BigInt와 Symbol를 호출하는 경우는 기본형을 생성하기 때문에 사용해도 문제없음.

```ts
typeof BigInt(1234);
("bigint");
typeof Symbol("sym");
("symbol");
```

- BigInt와 Symbol ‘값’ 이지만, 타입스크립트 타입은 아님.
- 위 코드의 결과값은 bigint와 symbol타입의 값이 됨.

요약

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼타입이 어떻게 쓰이는지 이해해야함.
- 객체 래퍼 타입을 직접 사용하거나 인스턴스를 생성하는것은 피해야함.
- 타입 스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야함.
- String대신 string, Number대신 number, Boolean 대신 boolean, Symbol 대신 symbol, BigInt 대신 bigint를 사용해야함.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 그 외 속성은 없는지 확인.

예제 1

```tsx
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
};
/*
Type '{ numDoors: number; ceilingHeightFt: number; elephant: string; }' is not assignable to type 'Room'.
  Object literal may only specify known properties, and 'elephant' does not exist in type 'Room'.
*/
```

- Room 타입에 생뚱맞은 elephant속성이 있는것이 어색하나, 구조적 타이핑 관점으로 생각했을때 오류가 발생하지 않아야함.
- 임시 변수를 도입하여 테스트 해보면 알 수 있음.

예제 2

```tsx
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
};
const r: Room = obj; //정상
```

- obj의 타입은 {numDoors:number; ceilingHeightFt:number; elephant:string} 으로 추론됨.
- obj 타입은 Room 타입의 부분 집합을 포함하므로, Rom에 할당가능하며, 타입 체커도 통과함.

두 예제 비교

- 예제 1에서는 구조적 타입 시스템에서 발생할 수 있는 오류를 잡을 수 있도록 ‘잉여 속성 체크’ 과정이 수행됨.
- 그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 존재.
- 통상적인 할당가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러움.
- 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는것을 인지해야함.

타입스크립트는 의도와 다르게 작성된 코드도 탐지시도함.

```tsx
interface Options {
  title: string;
  darkMode?: boolean;
}
function createWindow(options: Options) {
  if (options.darkMode) {
    // setDarkMode();
  }
}
createWindow({
  title: "Spider Solitaire",
  darkmode: true,
});

/**
Argument of type '{ title: string; darkmode: boolean; }' is not assignable to parameter of type 'Options'.
  Object literal may only specify known properties, but 'darkmode' does not exist in type 'Options'. Did you mean to write 'darkMode'?
*/
```

- 위 코드는 런타임에는 아무 에러가 없음.
- 그러나 타입스크립트에서 알려주는 오류 메시지처럼 의도한 대로 동작하지 않을 가능성이 존재.
- 오류 내용은 darkmode가 아닌 darkMode(대문자M)이어야 함.

```tsx
const o1: Options = document; //정상
const o2: Options = new HTMLAnchorElement(); //정상
```

- Options 타입은 범위가 매우 넓으므로, 순수한 구조적 타입 체커는 이런 종류의 에러를 찾지 못함.
- document와 HTMLAnchorElement의 인스턴스 모두 string 타입인 title속성을 가지고 있어 할당문은 정상처리.

```tsx
const o: Options = { darkmode: true, title: "Ski Free" };
//Options 형식에 darkmode가 없음.
```

- 위 구문은 에러 발생

```tsx
const intermediate = { darkmode: true, title: "Ski Free" };
const o: Options = intermediate; //정상
```

- 타입 구문이 없는 임시변수를 사용하여 테스트
- 첫 번째 라인의 오른쪽은 객체 리터럴이지만, 두 번째 줄의 오른쪽(intermediate)은 객체 리터럴이 아님.
- 따라서 잉여 속성 체크는 적용되지 않고 오류가 사라짐.

```tsx
const o = { darkmode: true, title: "Ski Free" } as Options; //정상
```

- 잉여 속성 체크는 단언문을 사용할때도 적용되지 않음.

```tsx
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknow;
}
const o: Options = { darkmode: true }; //정상
```

- 잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있음.

```tsx
interface LineChartOptions {
  logscale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}
const opts = { logScale: true };
const o: LineChartOptions = opts;
// Type '{ logScale: boolean; }' has no properties in common with type 'LineChartOptions'.
```

- 구조적 관점에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함 가능.
- 이런 약한(Weak) 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행.
- 공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는데 효과적이며 구조적으로 엄격하지 않음.
- 그러나 잉여 속성 체크와는 달리, 약한 타입과 관련된 할당문 마다 수행됨.
- 임시 변수를 제거하여도 공통 속성 체크는 여전히 동작

**요약**

- 객체 리터럴을 변수에 할당하거나, 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됨.
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다름
- 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조 할당 가능성 체크를 구분할 수 있음.
- 잉여 속성 체크에는 한계가 있음. 임시 변수를 도입하면 잉여 속성 체크를 건너 뛸 수 있음.

## 함수 표현식에 타입 적용하기

```tsx
function rollDice1(sides:number): number {/*...*/} //문장
const rollDice2 = function (sides:number):number {/*...*/} ********//표현식
const rollDice3 = function (sides:number):number => {/*...*/} //표현식********
```

- 자바스크립트 및 타입스크립트는 함수 문장과 표현식을 다르게 인식.
- 타입스크립트에서는 함수 표현식 사용을 권장
- 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용 할 수 있음.

```tsx
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = (sides) => {
  /* ... */
};
```

- 타입스크립트에서 sides를 이미 number로 인식.

```tsx
function add(a: number, b: number) {
  return a + b;
}
function sub(a: number, b: number) {
  return a - b;
}
function mul(a: number, b: number) {
  return a * b;
}
function div(a: number, b: number) {
  return a / b;
}
```

```tsx
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

- 반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수 있음.
- 라이브러리는 공통 함수 시그니처를 타입으로 제공하기도 함.
- 예를 들어 리액트는 MouseEvent 타입 대신 함수 전체에 적용할 수 있는 MouseEventHandler 타입을 제공.
- 라이브러리를 직접 만들고 있다면, 공통 콜백 함수를 위한 타입 선언을 제공하는게 좋음.

시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입을 적용해 볼 만함.

```tsx
//http 요청 보냄
const responseP = fetch("/quote/?by=Mark+Twain"); //타입이 Promise<Response>
```

```tsx
async function getQuote() {
  const response = await fetch("/quote?by=Mark+Twain");
  const quote = await response.json();

  return quote;
}
//response
//{
// "quote" : "If you tell ... bla bla",
// "source" : "notebook",
// "date" : "1894"
//}
```

- 위 코드에는 드러나지 않은 버그가 있음.
- `/quote` 가 존재하지 않는 API라면, ‘404 Not Found’ 가 포함된 내용을 응답함.
- 따라서 응답은 JSON 형식이 아닐 수 있음.
- response.json()은 JSON 형식이 아니라는 새로운 오류 메시지를 담아 거절된 (rejected) 프로미스를 반환.
- 호출한 곳에서는 새로운 오류 메시지가 전달되어 실제 오류인 404가 감추어짐.
- 또한 fetch가 실패하면 거절된 프로미스를 응답하지 않는다는 점을 간과하기 쉬움.

상태 체크를 수행해줄 checkedFetch 함수 작성

```tsx
//lib.dom.d.ts에 정의된 fetch의 타입선언
declare function fetch(
  input: RequestInfo,
  init?: RequestInit
): Promise<Response>;
```

checkedFetch 정의

```tsx
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
  const response = await fetch(input, init);
  if (!response.ok) {
    //비동기 함수 내에서 거절된 프로미스로 반환
    throw new Error("Request failed: " + response.status);
  }
  return response;
}
```

```tsx
//checkedFetch를 보다 간결하게 표현
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error("Request failed: " + response.status);
  }
  return respose;
};
```

- 간결한 버전에서는 `typeof fetch` 이 적용되어 input과 init의 타입 추론을 할 수 있게 해줌.
- 타입 구문은 checkedFetch의 반환 타입을 보장하며, fetch와 동일함.
- 예를 들어 throw 대신 return을 사용했다면 타입 스크립트는 그 실수를 잡아냄.

```tsx
const checkedFetch: typeof fetch = async (input, init) => {
  //에러
  //Type '(input: RequestInfo | URL, init: RequestInit | undefined) => Promise<Response | Error>' is not assignable to type '(input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>'.
  //Type 'Promise<Response | Error>' is not assignable to type 'Promise<Response>'.
  //Type 'Response | Error' is not assignable to type 'Response'.
  //Type 'Error' is missing the following properties from type 'Response': headers, ok, redirected, status, and 11 more.

  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error("Request failed: " + response.status);
  }
  return response;
};
```

- checkedFetch를 함수 문장으로 작성한 예시에서도 throw가 아니라 return을 사용한 경우 동일한 오류 발생(단 오류 위치는 함수를 호출한 위치에서 발생함)

정리

- 함수의 매개변수나 반환값에 타입을 명시하기 보다는 함수 표현식 전체에 타입 구문을 적용하는것이 좋음.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아볼것.
- 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야함.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 됨.
