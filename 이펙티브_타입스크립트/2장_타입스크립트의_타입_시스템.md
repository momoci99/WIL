# 2장 타입스크립트의 시스템

## 편집기를 사용하여 타입시스템 탐색

- 편집기(VS Code or Visual Studio)에서 타입 스크립트 언어를 적극 활용
- 편집기 사용시 타입시스템, 타입스크립트가 타입을 추론하는 개념을 알 수 있음.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기위해 타입 선언 파일을 찾아보는 방법 숙지.

## 타입이 값들의 집합이라고 생각하기

- 변수에는 다양한 종류의 값을 할당할 수 있음
- 타입스크립트는 오류를 체크하는 순간에는 타입을 가지고 있음.
- 타입을 `할당 가능한 값들의 집합(혹은 범위)` 이라고 생각하면 됨.

e.g

- 42와 37.5는 `number` 타입.
- ‘Canada’ 는 `string` 타입.
- null과 undefined는 `strictNullChecks` 플래그 사용 여부에 따라 number에 해당 될 수도, 아닐 수도 있음.

**공집합 타입 never**

- 타입스크립트의 가장 작은 집합은 `nerver` 이며 아무 값도 포함하지 않는 공집합.

**유닛(unit) 타입 혹은 리터릴(literal)타입**

- never 다음으로 작은 타입. 한가지 값만 포함하고 있음.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
```

**두개 혹은 세개로 묶으려면 유니온(union)타입을 사용**

```typescript
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 세개 이상의 타입을 묶을때로 동일하게 | 로 이어주면 됨.

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/ae66a753-db64-4b26-9c4c-db3d7e846810/Untitled.png)

- ‘C’는 유닛 타입으로서, 범위는 단일값 `"C"` 구성. 따라서 AB(”A”와 “B”로 이루어진) 부분집합이 아니므로 오류 발생
- 집합의 관점에서 타입체커의 역할은 하나의 집합이 다른 집합의 부분집합인지 검사하는것.
- declare 설명 : https://www.typescriptlang.org/ko/docs/handbook/declaration-files/by-example.html

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f742c95a-eab9-4c34-b662-d76dd7a87f44/Untitled.png)

- AB12는 AB의 부분집합이 될 수 없으므로 에러 발생.

e.g

```ts
type Int = 1 | 2 | 3 | 4 | 5; // | ..

interface Identified {
  id: string;
}
```

- 범위가 무한대인 경우 원소를 일일이 추가(첫번째)하는 방법도 있겠으나 원소를 서술(두번째)
- 어떤 객체가 string으로 할당가능한 id 속성을 가지고 있다면 그 객체는 Identified 타입으로 볼 수 있음.
- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성을 가질 수 있음을 의미.
- 함수 호출의 매개변수에서도 다른 속성을 가질 수 있음.
- 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(express property checking : [링크](https://dev.to/this-is-learning/understanding-excess-property-checking-in-typescript-ook))만 생각하다보면 간과하기 쉬움

### & 연산자 - 인터섹션(intersection)

e.g

```typescript
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

- `&` 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산함.
- 겉으로 보았을 때, Person과 Lifespan 인터페이스는 공통 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬움.
- 그러나 타입 연산자는 인터페이스의 속성이 아닌 값의 집합(타입의 범위)에 적용.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/2aa7f076-3ab6-4150-9a21-c3ee431ee0ac/Untitled.png)

- 그래서 Person과 Lifespan을 둘다 가지는 값은 인터섹션 타입에 속하게됨.
- 인터섹션 타입의 값은 각 타입 내의 모든 속성을 포함하는 것이 일반적.

### **| 연산자 - 유니온(Union)**

e.g

```ts
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
```

- 값들의 합집합을 뜻함.
- 세개 이상의 타입을 묶을때도 `|` 로 이어줄 수 있음.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/a0d59c34-ce25-40e5-87f0-c128b424a476/Untitled.png)

- 두 인터페이스 Person 과 Lifespan의 유니온은 `never` .

e.g

- 인터섹션과 유니온 연산에 대해서는 아래의 수식이 성립

```ts
keyof (A & B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

_여기서 keyof 는 오브젝트(타입, 인터페이스 포함)의 키값을 추출하여 union형태로 반환하는 연산자_

e.g

- 일반적으로 위에서 정의한 `PersonSpan` 을 정의할때는 `extends` 사용

```ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

- 타입이 집합이라는 관점하에 `extends`의 의미는 “~에 할당가능한 과 비슷하게” ,” ~의 부분집합이라는 의미로 받아들일 수 있음.
- `PersonSapn` 타입의 모든 값은 문자열 name 속성을 가져야함.
- 그리고 birth 속성을 가져야 제대로 된 부분 집합이 됨.

e.g

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D extends Vector1D {
  y: number;
}
interface Vercotr3D extends Vector2D {
  z: number;
}
```

- 어떤 집합이 다른 집합의 부분 집합일 때 ‘서브 집합’ 이라고 칭함.
- Vector3D는 Vector2D의 서브타입.
- Vector2D는 Vector1D의 서브타입.

e.g

extends키워드 없이 동일하게 인터페이스를 작성한다면 아래와 같음

```ts
interface Vercotr1D {
  x: number;
}
interface Vercotr2D {
  x: number;
  y: number;
}
interface Vercotr3D {
  x: number;
  y: number;
  z: number;
}
```

- 집합은 바뀌지 않음.
- 두 스타일 모두 객체 타입에 대해서 잘 동작하나, 리터럴 타입과 유니온 타입을 생각해 본다면, 집합 스타일이 더 직관적.
- extends 키워드는 제너릭 타입에서 한정자로도 쓰임 (~의 부분집합의 의미)

```ts
function getKey<K extends string>(val: any, key: K) {
  //...
}
```

```ts
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; //타입은 "x" | "y"

function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  //...
}

const pts: Point[] = [
  { x: 1, y: 1 },
  { x: 2, y: 0 },
];
sortBy(pts, "x"); //정상, 'x'는 'x' | 'y'를 상속 (즉 keyof T)
sortBy(pts, "y"); //정상, 'y'는 'x' | 'y' 를 상속
sortBy(pts, Math.random() < 0.5 ? "x" : "y"); //정상, 'x' | 'y' 는 'x' | 'y' 를 상속
sortBy(pts, "z"); //error : "z" 형식의 인수는 'x' | 'y' 형식의 매개변수에 할당될 수 없음.
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/88cf55fc-6b26-4f5a-ae57-5c4bed1c4261/Untitled.png)

- 타입들이 엄격한 상속 관계가 아닐 때는 집합 스타일이 더 바람직함.
- string | Number와 string | Date 의 인터섹션 (`&`) 은 공집합이 아니며 (이때는 string) 서로의 부분 집합도 아님.
- 타입들이 엄격한 상속 관계가 아니더라도 범위에 대한 관계는 명확함 (그림참조)

e.g

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/f6b897c4-76cc-4cf4-8578-d9e58b15bba0/Untitled.png)

- 타입이 집합이라는 관점은 위의 예를 통해 명확히 알 수 있음.
- 위 코드에서 숫자 배열을 숫자들의 쌍(pair)라고는 할 수 없음. 빈 리스트와 [1]이 그 반례
- number[]는 [number, number]의 부분 집합이 아니므로 할당할 수 없음(반대로 할당시 동작함)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/11615347-78fe-4e11-9731-f6f3f26cb620/Untitled.png)

- 동일한 이유로 위의 코드는 동작하지 않음.
- 타입이 값의 집합이라는 의미는 동일한 값의 집합을 가지는 두 타입은 같다는 의미.
- 만약, 두 타입이 의미적으로 다르고 우연히 같은 범위를 가진다 하여도 같은 타입을 두번 정의할 필요는 없음.

e.g

```tsx
// 타입은 Date
// string | Date 와 string | number의 인터섹션 타입중 string을 string | Date 에서 제외
// 그러므로 타입은 Date
type T = Exclude<string | Date, string | number>;

//타입은 여전히 number
type NonZeroNums = Exclude<number, 0>;
```

- 타입 스크립트 타입이 되지 못하는 값의 집합들이 있다는것을 기억해야함.
- 예제처럼 Exclude를 사용해서 일부 타입을 제외할 수는 있으나, 그 결과가 적절한 타입스크립트 타입일 때만 유효함

| 타입 스크립트 용어           | 집합 용어                                        |     |
| ---------------------------- | ------------------------------------------------ | --- |
| nerver                       | Ø(공집합)                                        |
| 리터럴 타입                  | 원소가 1개인 집합                                |
| 값이 T에 할당 가능           | 값 ∈ T (값이 T의 원소)                           |
| T1이 T2에 할당가능           | T1 ⊆ T2 (T1이 T2의 부분 집합)                    |
| T1이 T2를 상속               | T1 ⊆ T2 (T1이 T2의 부분 집합)                    |
| T1                           | T2 (T1과 T2의 유니온) T1 ∪ T2 (T1과 T2의 합집합) |
| T1 & T2 (T1과 T2의 인터섹션) | T1 ∩ T2 (T1과 T2의 교집합)                       |
| unknown                      | 전체(universal) 집합                             |

요약

- 타입을 값의 집합으로 생각하면 이해하기 쉬움(타입의 범위)
- 이 집합은 유한(boolean 또는 리터럴)하거나 무한(number 또는 string)함.
- 타입스크립트는 엄격한 상속관계가 아니라 겹쳐지는 집합(밴 다이어 그램)으로 표현.
- 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있음.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있음.
- 타입 연산은 집합의 범위에 적용. A와 B의 인터섹션(&) 은 A와 B의 범위의 인터섹션.
- 객체타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미함.
- ‘A는 B를 상속’, ‘A는 B에 할당 가능’, ‘A는 B의 서브타입’ 은 ‘A는 B의 부분 집합’ 과 같은 의미.

## 타입 공간과 값을 공간의 심벌 구분하기.

e.g

```tsx
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({ radius, height });
```

- interface Cylinder에서 Cylinder는 타입으로 쓰임.
- const Cylinder에서 Cylinder와 이름은 같으나 값으로 쓰이며, 서로 아무 관련도 없음.
- 상황에 따라 Cylinder는 타입으로 쓰이거나, 값으로 쓰일 수 있음.
- 이런 부분이 가끔 오류를 야기함.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/a6cc1e40-7151-468d-9376-b3ba3aacf475/Untitled.png)

- instanceof를 이용하여 shape가 Cylinder 타입인지 체크를 시도.
- 그러나 instanceof는 런타임 연산자이며 값에 대한 연산만 수행.
- 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조.

e.g

```tsx
type T1 = "string literal";
type T2 = 123;
const v1 = "string literal";
const v2 = 123;
```

- 일반적으로 type이나 interface 다음에 나오는 심벌은 타입.
- const, let 다음에 나오는 심벌은 값.

e.g

```tsx
//type T1 = 'string literal';
//type T2 = 123;
//const v1 = 'string literal';
//const v2 = 123;

//타입 선언은 컴파일 후 사라진다.
"use strict";
const v1 = "string literal";
const v2 = 123;
```

- 컴파일 후 심벌이 사라진다면 타입에 해당됨.

e.g

```tsx
class Cylinder {
  radius = 1;
  height = 1;
}

function caculatorVolume(shape: unknow) {
  if (shape instanceof Cylinder) {
    shape; //정상. 타입은 Cylider
    shape.radius; //정상 타입은 number
  }
}
```

- class와 enum은 상황에 따라 타입과 값 두가지 모두 가능한 예약어
- 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용됨.
- 반면 값으로 쓰일때는 생성자가 사용됨.

```tsx
interface Person {
  first: string;
  last: string;
}

const p: Person = { first: "Jane", last: "Jacobs" };

function email(p: Person, subject: string, body: string): Response {}

type T1 = typeof p; //타입은 Person
type T2 = typeof email; //타입은 (p: Person, subject:string, body:string):Response

const v1 = typeof p; // 값은 "object"
const v2 = typeof email; //값은 "function"
```

- 타입의 관점에서 typeof는 값을 읽어서 타입스크립트 타입을 반환.
- 타입의 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있음.
- 혹은 type 구문으로 이름을 붙이는 용도로 사용할 수 있음.

javascript의 typeof

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof

- 값의 관점에서 typeof는 자바스크립트 런타임의 typeof연산자가 됨.
- 값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환.
- 타입스크립트와는 다름.
- 자바스크립트의 런타임 타입 시스템은 타입스크립트의 정적 타입시스템보다 훨씬 간단하게 동작.

타입스크립트 타입의 종류에 비해 자바스크립트는 지금까지 단 7개가 존재(책에서는 6개지만 현재 js스펙이 올라가면서 7개로 변경됨) (string, number, boolean, undefined, object, function, symbol)

- 자바스크립트의 기본 타입
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures

- 타입스크립트에서의 typeof 설명

- class키워드는 값과 타입 두가지로 모두 사용됨.
- 따라서 클래에 대한 typeof는 상황에 따라 다르게 동작함.

```ts
const v = typeof Cylinder; //값이 "function"
type T = typeof Cylinder; //타입이 typeof Cylinder
```

- 클래스는 자바스크립트에서 실제 함수로 구현되므로 첫번째 줄의 값은 “function”이 됨.
- Cylinder가 인스턴스의 타입이 아니라는 점에 주목.

```ts
declare let fn: T;
const c = new fn(); //타입이 Cylinder
```

- 실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수.

```ts
type C = InstanceType<typeof Cylinder>; //타입이 Cylinder
```

- InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환가능.

```ts
const first: Person["first"] = p["first"]; //또는 p.first
```

- 속성 접근자인 []는 타입으로 쓰일 때에도 동일하게 동작함.
- 그러나 obj[’field’] 와 obj.field는 값이 동일하더라도 타입은 다를 수 있음.
- 따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법(obj[’field’])를 사용해야함.
- Person[’first’]는 여기서 타입 맥락으로 사용되었으므로 타입.
- 인덱스 위치에는 유니온 타입과 기본형 타입을 포함한 어떤 타입이든 사용할 수 있음.

```ts
type PersonEl = Person["first" | "last"]; //타입은 string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // 타입 string | number | Date
```

속성 접근자에 대한 정리

**this**

- 값으로 쓰이는 this는 자바스크립트의 this의 키워드.
- 타입으로 쓰이는 this는 일명 다형성(polymorphic) this라고 불리는 this의 타입스크립트 타입.
- 서브클래스의 메서드 체인을 구현할 때 유용.

**& |**

- 값에서 & 와 | 는 AND 와 OR 비트연산자로 사용
- 타입에서는 인터섹션과 유니온

const

- const는 새 변수를 선언.
- as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 변경.

extends

- extends는 서브클래스(class A extends B)또는 서브타입(interface A extends B) 또는 제너릭 한정자(Generic<T extends number>)를 정의.

in

- 루프(for (key in object))또는 매핑된(mapped)타입에 등장.

타입 공간과 값 공간을 혼동하여 발생할 수 있는 케이스

```tsx
function email(options: { person: Person; subject: string; body: string }) {
  // ...
}
```

- 자바스크립트에서 객체 내 각 속성을 로컬 변수로 만들어주는 구조 분해 할당을 사용하여 위의 코드를 아래와 같이 변경

```tsx
function email ({person, subject, body}) //in javascript

//타입 스크립트에서는 아래 코드에 에러가 발생
function email({
	person:Person,
	subject:string,
	body: string}

}){
	//...
}
```

- 값의 관점에서 Person과 string이 해석되었으므로 에러가 발생하게됨.
- Person이라는 변수명과 string이라는 이름을 가지는 두개의 변수를 생성하려고 시도한것.
- 타입과 값을 구분하여 해결가능

```tsx
function email(
{person, subject, body} : {person: Person, subject:string, body:string} {
	//...
}
```

- 코드가 장황ㅎ하여도 매개변수에 명명된 타입을 사용하거나 문맥에서 추론하도록 잘 동작.

## 타입 단언보다는 타입 선언을 사용하기

```tsx
interface Person {
  name: string;
}

const alice: Person = { name: "Alice" }; //타입은 Person
const bob = { name: "Bob" } as Person; //타입은 Person
```

- 이 두가지 방법은 결과가 같아보이나 전혀 그렇지 않음.
- 첫번째 alice:Person은 변수에 ‘타입 선언’을 붙여서 그 값이 선언된 타입을 명시
- 두번째 as Person은 ‘타입 단언’ 을 수행. 타입스크립트가 이미 추론한 타입이 있더라도 Person 타입으로 간주함.
- 타입 단언보다 타입 선언을 사용하는게 더 나음.

```tsx
const alice: Person = {};
//~~~ 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
const bob = {} as Person; //오류 없음.
```

- 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사함.
- 이전의 예제는 그러지 못하였으므로 (alice 케이스) 타입스크립트가 오류를 표시.
- 타입 단언(bob 케이스)은 강제로 타입을 지정하였으므로 타입 체커에게 오류를 무시하라고 하는것.

```tsx
const alice: Person = {
  name: "Alice",
  occupation: "Typescript developer",
};

const bob = {
  name: "bob",
  occupation: "Javascript developer",
} as Person;
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6a9964a5-a4b3-478c-a26c-202e04bf6b13/af315dee-6905-49d0-b123-a92e90404542/Untitled.png)

- 타입 선언문에는 잉여 속성 체크가 동작했으나, 단언문에는 적용되지 않음.
- 타입 단언이 꼭 필요한 경우가 아니라면 안전성 체크도 되는 타입 선언을 사용 권장

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있음.

```tsx
const people = ["alice", "bob", "jan"].map((name) => ({ name }));
//Persone[]을 원했으나 결과는 {name:string;}[]...

const people = ["alice", "bob", "jan"].map((name) => ({ name } as Person));
//타입은 Person[] 이겠으나 런타임에 문제발생
```

- 타입 단언을 사용하여 앞선 예제들처럼 런타임에 문제가 발생

```tsx
const people = ["alice", "bob", "jan"].map((name) => ({} as Person));
//오류 없음
```

개선 버전 1

```tsx
const people = ["alice", "bob", "jan"].map((name) => {
  const person: Person = { name };
  return person;
}); //타입은 Person[]
```

개선 버전 2

```tsx
const people = ["alice", "bob", "jan"].map((name): Person => ({ name }));
//타입은 Person[]
```

- (name):Person은 name의 타입이 없고, 반환 타입이 Person임을 명시.
- 그러나 (name: Person)은 name의 타입이 Person임을 명시하고 반환 타입이 없으므로 오류가 발생

개선 버전 3

```tsx
const people: Person[] = ["alice", "bob", "jan"].map(
  (name): Person => ({ name })
);
```

- 최종적으로 원하는 타입을 명시
- 타입스크립트가 할당문의 유효성을 검사하게함
- 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야함. 그래야 오류 표기가 정확해짐

타입 단언이 반드시 필요한 경우

```tsx
document.querySelector("#myButton").addEventListener("click", (e) => {
  e.currentTarget; //타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button; //타입은 HTMLButtonElement;
});
```

- 타입스크립트는 DOM에 접근할 수 없으므로 #myButton이 버튼 엘리먼트인지 알지 못함.
- 이벤트의 currentTarget이 같은 버튼이여야하는것도 알지 못함.
- 타입스크립트가 알지 못하는 정보를 가지고 있으므로 타입 단언문을 사용하는것이 타당함.

타입 단정문 `!` - null이 아님을 단언하는 경우.

```tsx
const elNull = document.getElementById("foo"); //타입은 HTMLElement | null
const el = document.getElementBy("foo")!; //타입은 HTMLElement
```

- 변수의 접두사로 쓰인 !는 boolean의 부정문
- 그러나 접미사로 쓰인 !는 그 값이 null이 아니라는 단언문으로 해석됨.
- !를 일반적인 단언문처럼 생각해야하며 컴파일중에 제거됨.
- 타입 체커는 알기 어려우나, 그 값이 null이 아님을 확신할 수 있을 때 사용해야함.
- 그렇지 않은 경우 반드시 null인 경우를 체크하는 조건문을 사용해야함.

타입 단언문의 한계

```tsx
interface Person {
  name: string;
}
const body = document.body;
const el = body as Person;
//에러 발생
//Conversion of type 'HTMLElement' to type 'Person' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
//Property 'name' is missing in type 'HTMLElement' but required in type 'Person'.
```

- 타입 단언문으로 임의의 타입 간에 변환을 할 수 는 없음.
- A가 B의 부분집합인 경우에 타입 단언문을 사용해 변환할 수 있음.
- Person과 HTMLElement는 서로의 서브타입이 아니므로 변환이 불가능.
- 이 에러를 해결하고 싶다면 unknown을 활용해야함.

```tsx
const el = document.body as unknown as Person; //정상
```

- 모든 타입은 unknown의 서브타입이므로 unknown이 포함된 단언문은 항상 동작.
- unknown을 사용한 이상 적어도 개발자에게 위험한 동작을 하고 있음을 알림.

요약

- 타입 단언(as Type)보다 타입 선언(:Type)을 사용.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야함.
- 타입스크립트보다 타입 정보를 더 잘 알고있는 상황에서는 타입 단언문 혹은 null 아님 단정문(!) 사용.

## 객체 래퍼 타입 피하기

- 자바스크립트 기본 타입들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됨
- 그러나 기본형인 string인 경우 메서드를 가지고 있는것 처럼 보임.

```tsx
"primitive".charAt(3);
//"m":
```

- 사실 charAt은 string의 메서드가 아니며 string을 사용할 때 자바스크립트 내부에서 변환 과정이 일어남.
- string 기본형에는 메서드가 없고, 메서드를 가지는 String ‘객체’ 타입이 정의되어있음.
- 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환.
- string 기본형에 charAt 같은 메서드를 사용할 때, 자바스크립트는 기본형을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버림.

String.prototype을 몽키 패치하여 위의 설명을 관찰가능.

```tsx
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function (pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};
console.log("primitive".charAt(3));

//출력
//String {'primitive'} 'object' 3
//m
```

- 메서드 내의 this는 string기본형이 아닌 String객체 래퍼.
- String객체를 직접 생성 할 수 있으며, string 기본형처럼 동작.
- 그러나 string기본형과 String객체 래퍼가 항상 동일하게 동작하는것은 아님.

```tsx
"hello" === new String("hello");
false;
new String("hello") === new String("hello");
false;
```

- String객체는 오직 자기 자신만 동일하게 취급.

```tsx
let x = "hello";
x.language = "English";
("English");
x.language;
undefined;
```

- 객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보일 때가 있음.
- 어떤 속성을 기본형에 할당하면 해당 속성은 사라짐.
- 실제로는 x가 String객체로 변환 된 후 language속성이 추가되었고, language속성이 추가된 객체는 버려진것.

타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링

- string / String
- number / Number
- boolean / Boolean
- symbol / Symbol
- bingint / BigInt

- 그러나 string을 사용할 때는 특히 유의.
- string을 String이라고 잘못 타이핑 하기 쉬우며, 실수를 하더라도 처음에는 잘 동작하는것으로 보임.

```tsx
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("hello");
getStringLen(new String("hello"));
//둘 다 정상 동작
```

- 그러나 string을 매개변수로 받는 메서드에 String 객체를 전달하는 순간 문제 발생

```tsx
function isGreeting(phrase: String) {
  return ["hello", "good day"].includes(phrase);
}

/*
 Argument of type 'String' is not assignable to parameter of type 'string'.
 'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.
*/
```

- string은 String에 할당할 수 있지만 String은 string에 할당할 수 없음.
- 오류 메세지대로 string타입을 사용해야함.
- 대부분의 라이브러리와 마찬가지로 타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로 되어있음.

```tsx
const s: String = "primitive";
const n: Number = 12;
const b: Boolean = true;
```

- 래퍼 객체는 타입 구문의 첫 글자를 대문자로 표기하는 방법으로도 사용할 수 있음.
- 당연히 런타임의 값은 객체가 아니고 기본형.
- 그러나 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용.
- 단, 기본형 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉽고, 굳이 그럴 필요도 없으므로 기본형 타입을 사용하는게 나음.

new 없이 BigInt와 Symbol를 호출하는 경우는 기본형을 생성하기 때문에 사용해도 문제없음.

```tsx
typeof BigInt(1234);
("bigint");
typeof Symbol("sym");
("symbol");
```

- BigInt와 Symbol ‘값’ 이지만, 타입스크립트 타입은 아님.
- 위 코드의 결과값은 bigint와 symbol타입의 값이 됨.

요약

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼타입이 어떻게 쓰이는지 이해해야함.
- 객체 래퍼 타입을 직접 사용하거나 인스턴스를 생성하는것은 피해야함.
- 타입 스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야함.
- String대신 string, Number대신 number, Boolean 대신 boolean, Symbol 대신 symbol, BigInt 대신 bigint를 사용해야함.
